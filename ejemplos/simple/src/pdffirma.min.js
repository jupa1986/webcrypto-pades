(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pdffirma = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
/*
 * PDFSign v1.0.0
 * https://github.com/Communication-Systems-Group/pdfsign.js
 *
 * Copyright 2015, Thomas Bocek, University of Zurich
 * Copyright 2018, Juan Carlos Canaza Ayarachi, jccarlos.a@gmail.com
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

var pvutils = require('pvutils');

var PDFDocument;

function createXrefTable(xrefEntries) {
    xrefEntries = sortOnKeys(xrefEntries);
    var retVal ='xref\n';
    var last = -2;
    for(var i in xrefEntries) {
        i = parseInt(i);
        if(typeof xrefEntries[i].offset === 'undefined') { continue; }
        retVal += calcFlow(i, last, xrefEntries);
        var offset = xrefEntries[i].offset;
        retVal += pad10(offset)+' '+pad5(xrefEntries[i].gen)+' '+(xrefEntries[i].free?'f':'n')+' \n';
        last = i;
    }
    return retVal;
}

function calcFlow(i, last, xrefEntries) {
    if(last + 1 === i) {return '';}
    var count = 1;
    while(typeof xrefEntries[(i+count)] !== 'undefined'
          && typeof xrefEntries[(i+count)].offset !== 'undefined') {count ++;}
    return i + ' '+count+'\n';
}

function createTrailer(topDict, startxref, sha256Hex, size, prev) {
    var retVal ='trailer <<\n';
    retVal +='  /Size '+(size)+'\n';
    var refRoot = topDict.getRaw('Root');
    if(typeof refRoot !== 'undefined') {
        retVal +='  /Root '+refRoot.num+' '+refRoot.gen+' R\n';
    }
    var refInfo = topDict.getRaw('Info');
    if(typeof refInfo !== 'undefined') {
        retVal +='  /Info '+refInfo.num+' '+refInfo.gen+' R\n';
    }
    retVal +='  /ID [<'+sha256Hex.substring(0,32)+'><'+sha256Hex.substring(32,64)+'>]\n';
    if(typeof prev !== 'undefined' ) {
        retVal +='  /Prev '+prev+'\n';
    }
    retVal +='>>\n';
    retVal +='startxref\n';
    retVal +=startxref + '\n';
    retVal +='%%EOF\n';
    return retVal;
}

function createXrefTableAppend(xrefEntries) {
    xrefEntries = sortOnKeys(xrefEntries);

    var retVal ='xref\n';
    var last = -2;
    for(var i in xrefEntries) {
        i = parseInt(i);
        if(typeof xrefEntries[i].offset === 'undefined') { continue; }
        retVal += calcFlow(i, last, xrefEntries);
        var offset = xrefEntries[i].offset;
        retVal += pad10(offset)+' '+pad5(xrefEntries[i].gen)+' '+(xrefEntries[i].free?'f':'n')+' \n';
        last = i;
    }
    return retVal;
}

//http://stackoverflow.com/questions/10946880/sort-a-dictionary-or-whatever-key-value-data-structure-in-js-on-word-number-ke
function sortOnKeys(dict) {
    var sorted = [];
    for(var key in dict) {
        sorted[sorted.length] = key;
    }
    sorted.sort();

    var tempDict = {};
    for(var i = 0; i < sorted.length; i++) {
        tempDict[sorted[i]] = dict[sorted[i]];
    }

    return tempDict;
}

function removeFromArray(array, from, to) {
    var cutlen = to - from;
    var buf = new Uint8Array(array.length - cutlen);

    for (var i = 0; i < from; i++) {
		buf[i] = array[i];
    }
    for (var i = to, len = array.length; i < len; i++) {
		buf[i-cutlen] = array[i];
    }
    return buf;
}

function pad10(num) {
	var s = "000000000" + num;
	return s.substr(s.length-10);
}

function pad5(num) {
	var s = "0000" + num;
	return s.substr(s.length-5);
}

function pad2(num) {
	var s = "0" + num;
	return s.substr(s.length-2);
}

function findRootEntry(xref) {
    var rootNr = xref.root.objId.substring(0, xref.root.objId.length - 1);
    return xref.entries[rootNr];
}

function findSuccessorEntry(xrefEntries, current) {
    //find it first
    var currentOffset = current.offset;
    var currentMin = Number.MAX_SAFE_INTEGER;
    var currentMinIndex = -1;
    for(var i in xrefEntries) {
        if(xrefEntries[i].offset > currentOffset) {
            if(xrefEntries[i].offset < currentMin) {
                currentMin = xrefEntries[i].offset;
                currentMinIndex = i;
                break;
            }
        }
    }
    if(currentMinIndex === -1) {
        return current;
    }
    return xrefEntries[currentMinIndex];
}

function updateArray(array, pos, str) {
    var upd = stringToUint8Array(str);
    for (var i = 0, len=upd.length; i < len; i++) {
        array[i+pos] = upd[i];
    }
    return array;
}

function copyToEnd(array, from, to) {
    var buf = new Uint8Array(array.length + (to - from));
    for (var i = 0, len=array.length; i < len; i++) {
        buf[i] = array[i];
    }

    for (var i = 0, len=(to - from); i < len; i++) {
        buf[array.length + i] = array[from + i];
    }
    return buf;
}

function insertIntoArray(array, pos, str) {
    var ins = stringToUint8Array(str);
    var buf = new Uint8Array(array.length + ins.length);
    for (var i = 0; i < pos; i++) {
        buf[i] = array[i];
    }
    for (var i = 0; i < ins.length; i++) {
		buf[pos+i] = ins[i];
    }
    for (var i = pos; i < array.length; i++) {
		buf[ins.length+i] = array[i];
    }
    return buf;
}

function stringToUint8Array(str) {
    var buf = new Uint8Array(str.length);
    for (var i=0, strLen=str.length; i<strLen; i++) {
        buf[i] = str.charCodeAt(i);
    }
    return buf;
}

function findFreeXrefNr(xrefEntries, used) {
    used = typeof used !== 'undefined' ?  used : [];
    var inc = used.length;

    for (var i=1;i<xrefEntries.length;i++) {

        var index = used.indexOf(i);
        var entry = xrefEntries[""+i];
        if(index === -1 && (typeof entry === 'undefined' || entry.free)) {
            return i;
	    }
        if(index !== -1) {
            inc--;
        }
	}
    return xrefEntries.length + inc;
}

function find(uint8, needle, start, limit) {
    start = typeof start !== 'undefined' ? start : 0;
    limit = typeof limit !== 'undefined' ? limit : Number.MAX_SAFE_INTEGER;

    var search = stringToUint8Array(needle);
    var match = 0;

    for(var i=start;i<uint8.length && i<limit;i++) {
        if(uint8[i] === search[match]) {
            match++;
        } else {
            match = 0;
            if(uint8[i] === search[match]) {
                match++;
            }
        }

        if(match === search.length) {
            return (i + 1) - match;
        }
    }
    return -1;
}

function findBackwards(uint8, needle, start, limit) {
    start = typeof start !== 'undefined' ? start : uint8.length;
    limit = typeof limit !== 'undefined' ? limit : Number.MAX_SAFE_INTEGER;

    var search = stringToUint8Array(needle);
    var match = search.length - 1;

    for(var i=start;i>=0 && i<limit;i--) {
        if(uint8[i] === search[match]) {
            match--;
        } else {
            match = search.length - 1;
            if(uint8[i] === search[match]) {
                match--;
            }
        }

        if(match === 0) {
            return i - 1;
        }
    }
    return -1;
}

function isSigInRoot(pdf) {
    if (typeof pdf.acroForm === 'undefined') {
        return false;
    }
    return pdf.acroForm.get('SigFlags') === 3;
}

function round256(x) {
    return (Math.ceil(x/256)*256) - 1;
}
/**
 * (D:YYYYMMDDHHmmSSOHH'mm)
 * e.g. (D:20151210164400+01'00')
 * where:
 * YYYY shall be the year
 * MM shall be the month (01–12)
 * DD shall be the day (01–31)
 * HH shall be the hour (00–23)
 * mm shall be the minute (00–59)
 * SS shall be the second (00–59)
 * O shall be the relationship of local time to Universal Time (UT), and shall be denoted by one of the characters PLUS SIGN (U+002B) (+), HYPHEN-MINUS (U+002D) (-), or LATIN CAPITAL LETTER Z (U+005A) (Z) (see below)
 * HH followed by APOSTROPHE (U+0027) (') shall be the absolute value of the offset from UT in hours (00–23)
 * mm shall be the absolute value of the offset from UT in minutes (00–59)
 */
function now(date) {
    date = typeof date !== 'undefined' ? date : new Date();
    var yyyy = date.getFullYear().toString();
    var MM = pad2(date.getMonth() + 1);
    var dd = pad2(date.getDate());
    var hh = pad2(date.getHours());
    var mm = pad2(date.getMinutes());
    var ss = pad2(date.getSeconds());
    return yyyy + MM + dd+  hh + mm + ss + createOffset(date);
}

function createOffset(date) {
    var sign = (date.getTimezoneOffset() > 0) ? "-" : "+";
    var offset = Math.abs(date.getTimezoneOffset());
    var hours = pad2(Math.floor(offset / 60));
    var minutes = pad2(offset % 60);
    return sign + hours + "'" + minutes;
}

async function newSig(webcrypto, pdf, root, rootSuccessor, date, password) {
    //copy root and the entry with contents to the end
    var startRoot = pdf.stream.bytes.length + 1;

    var limit;
    if (root.offset == rootSuccessor.offset)
        limit = find(pdf.stream.bytes, 'endobj', root.offset) + 6;
    else
        limit = rootSuccessor.offset;

    var array = copyToEnd(pdf.stream.bytes, root.offset - 1, limit);

    //since we signed the first one, we know how the pdf has to look like:
    var offsetForm = find(array, '<<', startRoot) +2;

    var offsetAcroForm = find(array, '/AcroForm<</Fields', startRoot);

    var annotEntry = findFreeXrefNr(pdf.xref.entries);
    var sigEntry = findFreeXrefNr(pdf.xref.entries, [annotEntry]);

    var appendAnnot = ' ' + annotEntry + ' 0 R';

    if (offsetAcroForm < 0) {
        var appendAcroForm = '/AcroForm<</Fields['+annotEntry+' 0 R] /SigFlags 3>>';
        array = insertIntoArray(array, offsetForm, appendAcroForm);
    } else {
        var endOffsetAcroForm = find(array, ']', offsetAcroForm);
        array = insertIntoArray(array, endOffsetAcroForm, appendAnnot);
    }


    //we need to add Annots [x y R] to the /Type /Page section. We can do that by searching /Annots
    var pages = pdf.catalog.catDict.get('Pages');
    //get first page, we have hidden sig, so don't bother
    var contentRef = pages.get('Kids')[0]; // pages.get('Kids').length - 1
    var xref = pdf.xref.fetch(contentRef);
    // var offsetAnnotEnd = xref.get('#Annots_offset');
    //we now search ], this is safe as we signed it previously
    // var endOffsetAnnot = find(array, ']', offsetAnnotEnd);
    var xrefEntry = pdf.xref.getEntry(contentRef.num);
    var xrefEntrySuccosser = findSuccessorEntry(pdf.xref.entries, xrefEntry);
    // var offsetAnnotRelative = endOffsetAnnot - xrefEntrySuccosser.offset;

    var startContent = array.length;
    array = copyToEnd(array, xrefEntry.offset, xrefEntrySuccosser.offset);
    // Find /Annots
    var offsetAnnot = find(array, '/Annots', startContent);

    if (offsetAnnot < 0) {
        offsetAnnot = find(array, '<<', startContent) + 2;
        appendAnnot = '/Annots['+appendAnnot+']\n ';
    } else {
        offsetAnnot = find(array, ']', offsetAnnot); // TODO
    }

    array = insertIntoArray(array, offsetAnnot, appendAnnot);

    var startAnnot = array.length;
    var append = annotEntry + ' 0 obj\n<</F 132/Type/Annot/Subtype/Widget/Rect[0 0 0 0]/FT/Sig/DR<<>>/T(signature'+annotEntry+')/V '+sigEntry+' 0 R>>\nendobj\n\n';
    array = insertIntoArray(array, startAnnot, append);

    var startSig = array.length;
    var start = sigEntry+ ' 0 obj\n<</Contents <';
    //TODO: Adobe thinks its important to have the right size, no idea why this is the case
    var crypto = new Array(round256(1024 * 6)).join( '0' );
    var middle = '>\n/Type/Sig/SubFilter/adbe.pkcs7.detached/Location()/M(D:'+now(date)+'\')\n/ByteRange ';
    var byteRange = '[0000000000 0000000000 0000000000 0000000000]';
    var end = '/Filter/Adobe.PPKLite/Reason()/ContactInfo()>>\nendobj\n\n';
    //all together
    var append2 = start+crypto+middle+byteRange+end;
    array = insertIntoArray(array, startSig, append2);

    let sha256Buffer = await webcrypto.subtle.digest('SHA-256', array);
    let sha256Hex = pvutils.bufferToHexCodes(sha256Buffer);

    var prev = findBackwards(array, 'startxref', array.length-1);
    prev = findBackwards(array, 'xref', prev);

    var startxref = array.length;
    var xrefEntries = [];
    xrefEntries[0] = {offset:0, gen:65535, free:true};
    xrefEntries[pdf.xref.topDict.getRaw('Root').num] = {offset:startRoot, gen:0, free:false};
    xrefEntries[contentRef.num] = {offset:startContent, gen:0, free:false};
    xrefEntries[annotEntry] = {offset:startAnnot, gen:0, free:false};
    xrefEntries[sigEntry] = {offset:startSig, gen:0, free:false};
    var xrefTable = createXrefTableAppend(xrefEntries);
    xrefTable += createTrailer(pdf.xref.topDict, startxref, sha256Hex, xrefEntries.length, prev);
    array = insertIntoArray(array, array.length, xrefTable);

    var from1 = 0;
    var to1 = startSig + start.length;
    var from2 = to1 + crypto.length;
    var to2 = (array.length - from2) - 1;
    var byteRange = '['+pad10(from1)+' '+pad10(to1 - 1) + ' ' +pad10(from2 + 1)+ ' ' + pad10(to2) + ']';

    array = updateArray(array, from2 + middle.length, byteRange);

    return [array, [from1, to1 - 1, from2 +1, to2]];
}

function signpdfEmpty(pdfRaw, crypto){
    const date = new Date();

    let pdf = parsePDF(pdfRaw);
    var root = findRootEntry(pdf.xref);

    var rootSuccessor = findSuccessorEntry(pdf.xref.entries, root);
    return newSig(crypto, pdf, root, rootSuccessor, date);
}

function parsePDF(pdfRaw) {
    if (pdfRaw instanceof ArrayBuffer)
        pdfRaw = new Uint8Array(pdfRaw);

    let pdf = new PDFDocument({evaluatorOptions:{}}, pdfRaw);
    pdf.parseStartXRef();
    pdf.parse();
    return pdf;
}

function setPDFDocument(_PDFDocument) {
    PDFDocument = _PDFDocument;
}

exports.signpdfEmpty = signpdfEmpty;
exports.parsePDF = parsePDF;
exports.removeFromArray = removeFromArray;
exports.updateArray = updateArray;
exports.setPDFDocument = setPDFDocument;

},{"pvutils":"pvutils"}],2:[function(require,module,exports){
var pkijs = require("pkijs");
var asn1js = require("asn1js");
var pvutils = require('pvutils');

const pdfsign = require('./pdfsign');

let trustedCertificates = []; // Array of Certificates

const CA64 = "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";

let asn2 = asn1js.fromBER(pvutils.stringToArrayBuffer(pvutils.fromBase64(CA64)));
let CA = new pkijs.Certificate({ schema: asn2.result });
trustedCertificates.push(CA);

function certificateRaw(provider, certID) {
    return Promise.resolve()
        .then(function () {
            return provider.certStorage.getItem(certID)
                .then(function (cert) {
                    return provider.certStorage.exportCert('raw', cert)
                        .then(function (raw) {
                            return raw;
                        });
                });
        });
}

function keyFromCertificateId(type, provider, certID) {
    return Promise.resolve()
        .then(function () {
            return provider.keyStorage.keys()
        })
        .then(function (keyIDs) {
            for (var i = 0; i < keyIDs.length; i++) {
                var keyID = keyIDs[i];
                var parts = keyID.split("-");

                if (parts[0] === type && parts[2] === certID.split("-")[2]) {
                    return provider.keyStorage.getItem(keyID);
                }
            }
            return null;
        })
        .then(function (key) {
            if (key || type !== "public") {
                return key;
            }

            return provider.certStorage.getItem(certID)
                .then(function (cert) {
                    return cert.publicKey;
                });
        });
}

function firstProvider(ws) {
    return listProviders(ws).then((providers) => {
        if (providers.length > 0)
            return ws.getCrypto(providers[0]);
        else
            throw new Error("Tokens no encontrados");
    });
}

function listProviders(ws) {
    return ws.info()
        .then(function (info) {
            let providers = [];
            for (let i = 0; i < info.providers.length; i++) {
                const provider = info.providers[i];
                if (provider.isHardware)
                    providers.push(provider.id);
            }
            return providers;
        });
}

function listCertificates(provider) {
    let certIDs, keyIDs;
    return Promise.resolve()    // Habilitar en el navegador
        .then(function () {
            if (typeof provider.isLoggedIn == "function") {
                return provider.isLoggedIn()
                    .then(function (ok) {
                        if (ok)
                            return provider.logout();
                    }).then(() => {
                        return provider.login();
                    });
            }
        })
        .then(function () {
            return provider.certStorage.keys()
        })
        .then(function (indexes) {
            certIDs = indexes.filter(function (id) {
                var parts = id.split("-");
                return parts[0] === "x509";
            });
        })
        .then(function () {
            return provider.keyStorage.keys()
        })
        .then(function (indexes) {
            keyIDs = indexes.filter(function (id) {
                var parts = id.split("-");
                return parts[0] === "private";
            });
        })
        .then(function () {
            var certificates = [];
            for (var i = 0; i < certIDs.length; i++) {
                var certID = certIDs[i];
                for (var j = 0; j < keyIDs.length; j++) {
                    var keyID = keyIDs[j];
                    if (keyID.split("-")[2] === certID.split("-")[2]) {
                        certificates.push(certID);
                        break;
                    }
                }
            }
            return certificates;
        });
}

function createCMSSigned(data, certSimpl, key) {

    let cmsSignedSimpl = new pkijs.SignedData({
        version: 1,
        encapContentInfo: new pkijs.EncapsulatedContentInfo({
            eContentType: "1.2.840.113549.1.7.1" // "data" content type
        }),
        digestAlgorithms: [],
        signerInfos: [
            new pkijs.SignerInfo({
                version: 1,
                sid: new pkijs.IssuerAndSerialNumber({
                    issuer: certSimpl.issuer,
                    serialNumber: certSimpl.serialNumber
                })
            })
        ],
        certificates: [certSimpl]
    });

    //TODO: añadir extensiones
    return cmsSignedSimpl.sign(key, 0, "sha-256", data).then(() => { // SHA-256 por defecto
        var cmsSignedSchema = cmsSignedSimpl.toSchema(true);
        var cmsContentSimp = new pkijs.ContentInfo({
            contentType: '1.2.840.113549.1.7.2',
            content: cmsSignedSchema
        });
        var _cmsSignedSchema = cmsContentSimp.toSchema(true);
        _cmsSignedSchema.lenBlock.isIndefiniteForm = true;

        var block1 = _cmsSignedSchema.valueBlock.value[1];
        block1.lenBlock.isIndefiniteForm = true;

        var block2 = block1.valueBlock.value[0];
        block2.lenBlock.isIndefiniteForm = true;
        var cmsSignedBuffer = _cmsSignedSchema.toBER(false);
        var cmsSignedHex = pvutils.bufferToHexCodes(cmsSignedBuffer);

        return cmsSignedHex;
    });
}

function signpdf(pdfRaw, key, certificate) {
    return pdfsign.signpdfEmpty(pdfRaw, pkijs.getEngine()).then(([pdf, byteRange]) => {
        let data = pdfsign.removeFromArray(pdf, byteRange[1], byteRange[2]);
        return createCMSSigned(data, certificate, key).then((signature) => { // hex
            return pdfsign.updateArray(pdf, byteRange[1] + 1, signature);
        });
    });
}

function listSigFields(pdf) {
    const sigFields = [];

    const acroForm = pdf.xref.root.get("AcroForm");
    if(typeof acroForm === "undefined")
        throw new Error("El PDF no tiene firmas!");

    const fields = acroForm.get("Fields");
    // TODO
    // if(window.isRef(fields[0]) === false)
    //      throw new Error("Wrong structure of PDF!");
    for (let i = 0; i< fields.length; i++) {
        const sigField = pdf.xref.fetch(fields[i]);
        const sigFieldType = sigField.get("FT");
        if((typeof sigFieldType === "undefined") || (sigFieldType.name !== "Sig"))
            // throw new Error("Wrong structure of PDF!");
            continue; //Ignorar Tx o Btn
        sigFields.push(sigField);
    }

    if (sigFields.length == 0)
        throw new Error("El PDF no tiene firmas!");

    return sigFields;
}

async function createOCSPReq(serialNumbers) {

    if (!(serialNumbers instanceof Array))
        serialNumbers = [serialNumbers];

    let extension = CA.extensions.find((extension) => {
        return extension.extnID == "2.5.29.14";
    });
    let issuerKeyHash = extension.parsedValue.valueBlock.valueHex;
    let issuerNameHash = await pkijs.getCrypto().subtle.digest('SHA-1', CA.subject.valueBeforeDecode);

    const ocspReq = new pkijs.OCSPRequest();
    let requestList = [];

    serialNumbers.forEach(serialNumber => {
        requestList.push(new pkijs.Request({
	        reqCert: new pkijs.CertID({
		        hashAlgorithm: new pkijs.AlgorithmIdentifier({
			        algorithmId: "1.3.14.3.2.26"
		        }),
		        issuerNameHash: new asn1js.OctetString({ valueHex: issuerNameHash }),
		        issuerKeyHash: new asn1js.OctetString({ valueHex: issuerKeyHash }),
		        serialNumber: new asn1js.Integer({ valueHex: serialNumber}) // cert.serialNumber.valueBlock.valueHex
	        })
        }));
    });

    ocspReq.tbsRequest.requestList = requestList;
    return ocspReq;
};

async function listSignatures(pdf, ocspReq) {
    const result = {data:[]};
    pdf = pdfsign.parsePDF(pdf);

    const sigFields = listSigFields(pdf);
    let serialNumbers = [];
    for (let i in sigFields) {
        let data = {};
        let sigField = sigFields[i];
        let v = sigField.get("V");
        let byteRange = v.get("ByteRange");
        let contents = v.get("Contents");

        let contentBuffer = pvutils.stringToArrayBuffer(contents);

        let asn1 = asn1js.fromBER(contentBuffer);
        let cmsContentSimp = new pkijs.ContentInfo({ schema: asn1.result });
        let cmsSignedSimp = new pkijs.SignedData({ schema: cmsContentSimp.content });

        let certificate = cmsSignedSimp.certificates[0];

        data.numeroSerie = pvutils.bufferToHexCodes(certificate.serialNumber.valueBlock.valueHex);
        serialNumbers.push(certificate.serialNumber.valueBlock.valueHex);

        let subFilter = v.get("SubFilter");
        let filter = v.get("Filter");
        data.subFilter = subFilter.name.toUpperCase();


        // Fecha de la firma desde el documento PDF
        // TODO: mejorar
        var date = v.get("M");
        var pattern = /D:(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})-0(\d{1})'00'/;

        if (date != undefined)
            data.fechaFirma = date.replace(pattern, '$3/$2/$1 $4:$5:$6');

        // Limpiar Campo de la firma
        let signedDataBuffer = pdfsign.removeFromArray(pdf.stream.bytes,
                                                        byteRange[1],
                                                        byteRange[2]);
        // Limpiar datos
        signedDataBuffer = pdfsign.removeFromArray(signedDataBuffer,
                                                    byteRange[1]+byteRange[3],
                                                    signedDataBuffer.length);

        data.autenticidad = await cmsSignedSimp.verify({signer: 0, data: signedDataBuffer,
                                                        trustedCertificates: trustedCertificates});

        data.cadenaConfianza = await certificate.verify(trustedCertificates[0]);
        // data.certificado = pvutils.toBase64(pvutils.arrayBufferToString(certificate.tbs));
        data.certificado = certificate;
        data.ocsp_estado = 2; // Desconocido por defecto.
        result.data.push(data);
    }

    let ocspReqBuffer = (await createOCSPReq(serialNumbers)).toSchema(true).toBER(false);

    if (ocspReq != undefined && typeof ocspReq == 'function'){
        try {
            [statusCode, ocspResBuffer] = await ocspReq(ocspReqBuffer);

            const asn1 = asn1js.fromBER(ocspResBuffer);
            const ocspRespSimpl = new pkijs.OCSPResponse({ schema: asn1.result });
            let ocspBasicResp;

            if (ocspRespSimpl.responseStatus.valueBlock.valueDec == 0) { // usar !=
                if("responseBytes" in ocspRespSimpl) {
                    const asn1Basic = asn1js.fromBER(ocspRespSimpl.responseBytes.response.
                                                     valueBlock.valueHex);
		            ocspBasicResp = new pkijs.BasicOCSPResponse({ schema: asn1Basic.result });
                    if (serialNumbers.length != ocspBasicResp.tbsResponseData.responses.length) {
                        // ERROR
                    }
                    for(let i = 0; i < ocspBasicResp.tbsResponseData.responses.length; i++)
	                {
                        const typeval = pvutils.bufferToHexCodes(ocspBasicResp.tbsResponseData.responses[i].
                                                                 certID.serialNumber.valueBlock.valueHex);
                        let subjval = ocspBasicResp.tbsResponseData.responses[i].certStatus.idBlock.tagNumber;

                        let data = result.data.find((data) => {
                            return data.numeroSerie == typeval;
                        });
                        if (data)
                            data.ocsp_estado = subjval;

                        if (subjval == 1) {
                            data.ocsp_fechaRevocacion = ocspBasicResp.tbsResponseData.
                                responses[i].certStatus.valueBlock.value[0].toDate()
                        }
                        data.ocsp_fechaActualizacion = ocspBasicResp.tbsResponseData.responses[i].thisUpdate;
                    }

                } else {
                    // ERROR
                }
            }
        } catch(err) {
            // OCSP no disponible
            console.log("OCSP no disponible:", err);
        }
    }

    return result;
}

function firstCertificate(provider) {
    let certRaw;
    let certID;

    let sequence = listCertificates(provider).then((certificados) => {
        if (certificados.length >0) {
            // Seleccionar el primer certificado
            certID = certificados[0];
            return certificateRaw(provider, certID);
        } else
            throw new Error("No hay certificados.");
    });

    sequence = sequence.then((raw) => {
        certRaw = raw;
        return keyFromCertificateId("private", provider, certID);
    });

    sequence = sequence.then((key) => {
        if (!key)
            throw new Error("Certificado no tiene llave privada.");


        const certSimpl = asn1js.fromBER(certRaw);
        const certificate = new pkijs.Certificate({ schema: certSimpl.result });

        return [key, certificate];
    });
    return sequence;
}

function setEngine(nombre, provider) {
    pkijs.setEngine(nombre, provider, new pkijs.CryptoEngine({name: 'local', crypto: provider, subtle: provider.subtle}));
}

exports.listCertificates = listCertificates;
exports.listProviders = listProviders;
exports.keyFromCertificateId = keyFromCertificateId;
exports.certificateRaw = certificateRaw;
exports.createCMSSigned = createCMSSigned;
exports.signpdf = signpdf;

exports.listSignatures = listSignatures;
exports.firstCertificate = firstCertificate;
exports.firstProvider = firstProvider;
exports.setEngine = setEngine;

},{"./pdfsign":1,"asn1js":"asn1js","pkijs":"pkijs","pvutils":"pvutils"}],"pdfjs-firma":[function(require,module,exports){
const signutils = require("./signutils");
const pdfsign =require("./pdfsign");

exports.listarCertificados = signutils.listCertificates;
exports.listarProveedores = signutils.listProviders;
exports.certificadoKey = signutils.keyFromCertificateId;
exports.certificadoRaw = signutils.certificateRaw;
exports.crearCMSFirmado = signutils.createCMSSigned;
exports.firmarPDF = signutils.signpdf;

exports.listarFirmas = signutils.listSignatures;
exports.primerCertificado = signutils.firstCertificate;
exports.primerProveedor = signutils.firstProvider;
exports.espacioFirma = pdfsign.signpdfEmpty;
exports.parsePDF = pdfsign.parsePDF;
exports.removeFromArray = pdfsign.removeFromArray;
exports.updateArray = pdfsign.updateArray;
exports.setPDFDocument = pdfsign.setPDFDocument;
exports.setEngine = signutils.setEngine;

},{"./pdfsign":1,"./signutils":2}]},{},[])("pdfjs-firma")
});