(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pdffirma = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
/*
 * PDFSign v1.0.0
 * https://github.com/Communication-Systems-Group/pdfsign.js
 *
 * Copyright 2015, Thomas Bocek, University of Zurich
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

//using the object if available or creating a new instance if not present

var pvutils = require('pvutils');

var PDFDocument;

var PDFSIGN = (function () {
    function createXrefTable(xrefEntries) {
        xrefEntries = sortOnKeys(xrefEntries);
        var retVal ='xref\n';
        var last = -2;
        for(var i in xrefEntries) {
            i = parseInt(i);
            if(typeof xrefEntries[i].offset === 'undefined') { continue; }
            retVal += calcFlow(i, last, xrefEntries);
            var offset = xrefEntries[i].offset;
            retVal += pad10(offset)+' '+pad5(xrefEntries[i].gen)+' '+(xrefEntries[i].free?'f':'n')+' \n';
            last = i;
        }
        return retVal;
    }

    function calcFlow(i, last, xrefEntries) {
        if(last + 1 === i) {return '';}
        var count = 1;
        while(typeof xrefEntries[(i+count)] !== 'undefined'
              && typeof xrefEntries[(i+count)].offset !== 'undefined') {count ++;}
        return i + ' '+count+'\n';
    }

    function createTrailer(topDict, startxref, sha256Hex, size, prev) {
        var retVal ='trailer <<\n';
        retVal +='  /Size '+(size)+'\n';
        var refRoot = topDict.getRaw('Root');
        if(typeof refRoot !== 'undefined') {
            retVal +='  /Root '+refRoot.num+' '+refRoot.gen+' R\n';
        }
        var refInfo = topDict.getRaw('Info');
        if(typeof refInfo !== 'undefined') {
            retVal +='  /Info '+refInfo.num+' '+refInfo.gen+' R\n';
        }
        retVal +='  /ID [<'+sha256Hex.substring(0,32)+'><'+sha256Hex.substring(32,64)+'>]\n';
        if(typeof prev !== 'undefined' ) {
            retVal +='  /Prev '+prev+'\n';
        }
        retVal +='>>\n';
        retVal +='startxref\n';
        retVal +=startxref + '\n';
        retVal +='%%EOF\n';
        return retVal;
    }

    function createXrefTableAppend(xrefEntries) {
        xrefEntries = sortOnKeys(xrefEntries);

        var retVal ='xref\n';
        var last = -2;
        for(var i in xrefEntries) {
            i = parseInt(i);
            if(typeof xrefEntries[i].offset === 'undefined') { continue; }
            retVal += calcFlow(i, last, xrefEntries);
            var offset = xrefEntries[i].offset;
            retVal += pad10(offset)+' '+pad5(xrefEntries[i].gen)+' '+(xrefEntries[i].free?'f':'n')+' \n';
            last = i;
        }
        return retVal;
    }

    //http://stackoverflow.com/questions/10946880/sort-a-dictionary-or-whatever-key-value-data-structure-in-js-on-word-number-ke
    function sortOnKeys(dict) {
        var sorted = [];
        for(var key in dict) {
            sorted[sorted.length] = key;
        }
        sorted.sort();

        var tempDict = {};
        for(var i = 0; i < sorted.length; i++) {
            tempDict[sorted[i]] = dict[sorted[i]];
        }

        return tempDict;
    }

    function removeFromArray(array, from, to) {
        var cutlen = to - from;
        var buf = new Uint8Array(array.length - cutlen);

        for (var i = 0; i < from; i++) {
		    buf[i] = array[i];
        }
        for (var i = to, len = array.length; i < len; i++) {
		    buf[i-cutlen] = array[i];
        }
        return buf;
    }

    function findXrefBlocks(xrefBlocks) {
        var num = xrefBlocks.length / 2;
        var retVal = [];
        for (var i=0;i<num;i++) {
            retVal.push({start: xrefBlocks[i], end: xrefBlocks[i+num]});
        }
        return retVal;
    }

    function pad10(num) {
	    var s = "000000000" + num;
	    return s.substr(s.length-10);
	}

    function pad5(num) {
	    var s = "0000" + num;
	    return s.substr(s.length-5);
	}

    function pad2(num) {
	    var s = "0" + num;
	    return s.substr(s.length-2);
	}

    function findRootEntry(xref) {
        var rootNr = xref.root.objId.substring(0, xref.root.objId.length - 1);
        return xref.entries[rootNr];
	}

    function findSuccessorEntry(xrefEntries, current) {
        //find it first
        var currentOffset = current.offset;
        var currentMin = Number.MAX_SAFE_INTEGER;
        var currentMinIndex = -1;
        for(var i in xrefEntries) {
            if(xrefEntries[i].offset > currentOffset) {
                if(xrefEntries[i].offset < currentMin) {
                    currentMin = xrefEntries[i].offset;
                    currentMinIndex = i;
                }
            }
        }
        if(currentMinIndex === -1) {
            return current;
        }
        return xrefEntries[currentMinIndex];
    }

    function updateArray(array, pos, str) {
        var upd = stringToUint8Array(str);
        for (var i = 0, len=upd.length; i < len; i++) {
            array[i+pos] = upd[i];
        }
        return array;
	}

    function copyToEnd(array, from, to) {
        var buf = new Uint8Array(array.length + (to - from));
        for (var i = 0, len=array.length; i < len; i++) {
            buf[i] = array[i];
        }

        for (var i = 0, len=(to - from); i < len; i++) {
            buf[array.length + i] = array[from + i];
        }
        return buf;
    }

    function insertIntoArray(array, pos, str) {
        var ins = stringToUint8Array(str);
        var buf = new Uint8Array(array.length + ins.length);
        for (var i = 0; i < pos; i++) {
            buf[i] = array[i];
        }
        for (var i = 0; i < ins.length; i++) {
		    buf[pos+i] = ins[i];
        }
        for (var i = pos; i < array.length; i++) {
		    buf[ins.length+i] = array[i];
        }
        return buf;
	}

    function stringToUint8Array(str) {
        var buf = new Uint8Array(str.length);
        for (var i=0, strLen=str.length; i<strLen; i++) {
            buf[i] = str.charCodeAt(i);
        }
        return buf;
	}

    function findFreeXrefNr(xrefEntries, used) {
        used = typeof used !== 'undefined' ?  used : [];
        var inc = used.length;

        for (var i=1;i<xrefEntries.length;i++) {

            var index = used.indexOf(i);
            var entry = xrefEntries[""+i];
            if(index === -1 && (typeof entry === 'undefined' || entry.free)) {
                return i;
	    	}
            if(index !== -1) {
                inc--;
            }
	    }
        return xrefEntries.length + inc;
	}

    function find(uint8, needle, start, limit) {
        start = typeof start !== 'undefined' ? start : 0;
        limit = typeof limit !== 'undefined' ? limit : Number.MAX_SAFE_INTEGER;

        var search = stringToUint8Array(needle);
        var match = 0;

        for(var i=start;i<uint8.length && i<limit;i++) {
            if(uint8[i] === search[match]) {
                match++;
            } else {
                match = 0;
                if(uint8[i] === search[match]) {
                    match++;
                }
            }

            if(match === search.length) {
                return (i + 1) - match;
            }
        }
        return -1;
    }

    function findBackwards(uint8, needle, start, limit) {
        start = typeof start !== 'undefined' ? start : uint8.length;
        limit = typeof limit !== 'undefined' ? limit : Number.MAX_SAFE_INTEGER;

        var search = stringToUint8Array(needle);
        var match = search.length - 1;

        for(var i=start;i>=0 && i<limit;i--) {
            if(uint8[i] === search[match]) {
                match--;
            } else {
                match = search.length - 1;
                if(uint8[i] === search[match]) {
                    match--;
                }
            }

            if(match === 0) {
                return i - 1;
            }
        }
        return -1;
    }

    function isSigInRoot(pdf) {
        if (typeof pdf.acroForm === 'undefined') {
            return false;
        }
        return pdf.acroForm.get('SigFlags') === 3;
    }

    function updateXrefOffset(xref, offset, offsetDelta) {
        for(var i in xref.entries) {
            if(xref.entries[i].offset >= offset) {
                xref.entries[i].offset += offsetDelta;
            }
        }
        for(var i in xref.xrefBlocks) {
            if(xref.xrefBlocks[i] >= offset) {
                xref.xrefBlocks[i]  += offsetDelta;
            }
        }
    }

    function updateXrefBlocks(xrefBlocks, offset, offsetDelta) {
        for(var i in xrefBlocks) {
            if(xrefBlocks[i].start >= offset) {
                xrefBlocks[i].start += offsetDelta;
            }
            if(xrefBlocks[i].end >= offset) {
                xrefBlocks[i].end += offsetDelta;
            }
        }
    }

    function updateOffset(pos, offset, offsetDelta) {
        if(pos >= offset) {
            return pos + offsetDelta;
        }
        return pos;
    }

    function round256(x) {
        return (Math.ceil(x/256)*256) - 1;
    }
    /**
     * (D:YYYYMMDDHHmmSSOHH'mm)
     * e.g. (D:20151210164400+01'00')
     * where:
     * YYYY shall be the year
     * MM shall be the month (01–12)
     * DD shall be the day (01–31)
     * HH shall be the hour (00–23)
     * mm shall be the minute (00–59)
     * SS shall be the second (00–59)
     * O shall be the relationship of local time to Universal Time (UT), and shall be denoted by one of the characters PLUS SIGN (U+002B) (+), HYPHEN-MINUS (U+002D) (-), or LATIN CAPITAL LETTER Z (U+005A) (Z) (see below)
     * HH followed by APOSTROPHE (U+0027) (') shall be the absolute value of the offset from UT in hours (00–23)
     * mm shall be the absolute value of the offset from UT in minutes (00–59)
     */
    function now(date) {
        date = typeof date !== 'undefined' ? date : new Date();
        var yyyy = date.getFullYear().toString();
        var MM = pad2(date.getMonth() + 1);
        var dd = pad2(date.getDate());
        var hh = pad2(date.getHours());
        var mm = pad2(date.getMinutes());
        var ss = pad2(date.getSeconds());
        return yyyy + MM + dd+  hh + mm + ss + createOffset(date);
    }

    function createOffset(date) {
        var sign = (date.getTimezoneOffset() > 0) ? "-" : "+";
        var offset = Math.abs(date.getTimezoneOffset());
        var hours = pad2(Math.floor(offset / 60));
        var minutes = pad2(offset % 60);
        return sign + hours + "'" + minutes;
    }

    async function newSig(webcrypto, pdf, root, rootSuccessor, date, password) {
        // {annotEntry} is the ref to the annot widget. If we enlarge the array, make sure all the offsets
        // after the modification will be updated -> xref table and startxref
        var annotEntry = findFreeXrefNr(pdf.xref.entries);

        // we'll store all the modifications we make, as we need to adjust the offset in the PDF
        // TODO: mejorar el limite.
        let limit = rootSuccessor.offset;
        if (root.offset == limit)
            limit = pdf.stream.bytes.length - 1;

        var offsetForm = find(pdf.stream.bytes, '<<', root.offset, limit) + 2;

        //first we need to find the root element and add the following:
        //
        // /AcroForm<</Fields[{annotEntry} 0 R] /SigFlags 3>>
        //
        var appendAcroForm = '/AcroForm<</Fields['+annotEntry+' 0 R] /SigFlags 3>>';
        //before we insert the acroform, we find the right place for annotentry

        //we need to add Annots [x y R] to the /Type /Page section. We can do that by searching /Contents[
        var pages = pdf.catalog.catDict.get('Pages');
        //get first page, we have hidden sig, so don't bother
        var ref = pages.get('Kids')[0];
        var xref = pdf.xref.fetch(ref);
        var offsetContentEnd = xref.get('#Contents_offset');
        var offsetAnnots = xref.get('#Annots_offset');
        var appendAnnots2 = ' '+annotEntry+' 0 R ';

        //we now search backwards, this is safe as we don't expect user content here
        var offsetContent = findBackwards(pdf.stream.bytes, '/Contents', offsetContentEnd);
        var appendAnnots = '/Annots['+annotEntry+' 0 R]\n ';

        //now insert string into stream
        var array = insertIntoArray(pdf.stream.bytes, offsetForm, appendAcroForm);
        //recalculate the offsets in the xref table, only update those that are affected
        updateXrefOffset(pdf.xref, offsetForm, appendAcroForm.length);
        offsetContent = updateOffset(offsetContent, offsetForm, appendAcroForm.length);
        if (typeof offsetAnnots == 'number') {
            var array = insertIntoArray(array, offsetAnnots, appendAnnots2);
            updateXrefOffset(pdf.xref, offsetAnnots, appendAnnots2.length);
        }  else {
            var array = insertIntoArray(array, offsetContent, appendAnnots);
            updateXrefOffset(pdf.xref, offsetContent, appendAnnots.length);
        }
        offsetContent = -1; //not needed anymore, don't update when offset changes

        //Then add to the next free object (annotEntry)
        //add right before the xref table or stream
        //if its a table, place element before the xref table
        //
        // sigEntry is the ref to the signature content. Next we need the signature object
        var sigEntry = findFreeXrefNr(pdf.xref.entries, [annotEntry]);

        //
        // {annotEntry} 0 obj
        // <</F 132/Type/Annot/Subtype/Widget/Rect[0 0 0 0]/FT/Sig/DR<<>>/T(signature)/V Y 0 R>>
        // endobj
        //
        var append = annotEntry + ' 0 obj\n<</F 132/Type/Annot/Subtype/Widget/Rect[0 0 0 0]/FT/Sig/DR<<>>/T(signature'+annotEntry+')/V '+sigEntry+' 0 R>>\nendobj\n\n';

        // we want the offset just before the last xref table or entry
        var blocks = findXrefBlocks(pdf.xref.xrefBlocks);

        var offsetAnnot = blocks[0].start;
        array = insertIntoArray(array, offsetAnnot, append);
        //no updateXrefOffset, as the next entry will be following

        //
        // {sigEntry} 0 obj
        // <</Contents <0481801e6d931d561563fb254e27c846e08325570847ed63d6f9e35 ... b2c8788a5>
        // /Type/Sig/SubFilter/adbe.pkcs7.detached/Location(Ghent)/M(D:20120928104114+02'00')
        // /ByteRange [A B C D]/Filter/Adobe.PPKLite/Reason(Test)/ContactInfo()>>
        // endobj
        //

        //the next entry goes below the above
        var offsetSig = offsetAnnot + append.length;

        // Both {annotEntry} and {sigEntry} objects need to be added to the last xref table. The byte range needs
        // to be adjusted. Since the signature will always be in a gap, use first an empty sig
        // to check the size, add ~25% size, then calculate the signature and place in the empty
        // space.
        var start = sigEntry+ ' 0 obj\n<</Contents <';
        // TODO: Calcular tamaño de la firma
        var crypto = new Array(round256(1024 * 6)).join( '0' );
        var middle = '>\n/Type/Sig/SubFilter/adbe.pkcs7.detached/Location()/M(D:'
            +now(date)+'\')\n/ByteRange ';
        var byteRange = '[0000000000 0000000000 0000000000 0000000000]';
        var end = '/Filter/Adobe.PPKLite/Reason()/ContactInfo()>>\nendobj\n\n';
        //all together
        var append2 = start+crypto+middle+byteRange+end;
        var offsetByteRange = start.length+crypto.length+middle.length;

        array = insertIntoArray(array, offsetSig, append2);
        updateXrefOffset(pdf.xref, offsetAnnot,
                         append2.length + append.length);

        //find the xref tables, remove them and also the EOF, as we'll write a new table
        var xrefBlocks = findXrefBlocks(pdf.xref.xrefBlocks);

        for(var i in xrefBlocks) {
            var oldSize = array.length;
            array = removeFromArray(array, xrefBlocks[i].start,
                                    xrefBlocks[i].end);
            var length = array.length - oldSize;
            updateXrefOffset(pdf.xref, xrefBlocks[i].start, length);

            //check for %%EOF and remove it as well
            var offsetEOF = find(array, '%%EOF',
                                 xrefBlocks[i].start,
                                 xrefBlocks[i].start+20);
            if(offsetEOF > 0) {
                var lengthEOF = '%%EOF'.length;
                array = removeFromArray(array, offsetEOF,
                                        offsetEOF + lengthEOF);
                updateXrefOffset(pdf.xref, offsetEOF, -lengthEOF);
                updateXrefBlocks(xrefBlocks, offsetEOF, -lengthEOF);
                offsetAnnot = updateOffset(offsetAnnot,
                                           offsetEOF, -lengthEOF);
                offsetSig = updateOffset(offsetSig, offsetEOF, -lengthEOF);
            }
            updateXrefBlocks(xrefBlocks, xrefBlocks[i].start, length);
            offsetAnnot = updateOffset(offsetAnnot,
                                       xrefBlocks[i].start, length);
            offsetSig = updateOffset(offsetSig,
                                     xrefBlocks[i].start, length);
        }

        let sha256Buffer = await webcrypto.subtle.digest('SHA-256', array);
        let sha256Hex = pvutils.bufferToHexCodes(sha256Buffer);

        //add the new entries to the xref
        pdf.xref.entries[annotEntry] = {offset:offsetAnnot, gen:0, free:false};
        pdf.xref.entries[sigEntry] = {offset:offsetSig, gen:0, free:false};

        ////////////////////
        var xrefTable = createXrefTable(pdf.xref.entries);
        //also empty entries count as in the PDF spec, page 720 (example)
        xrefTable += createTrailer(pdf.xref.topDict, array.length,
                                   sha256Hex, pdf.xref.entries.length);
        array = insertIntoArray(array, array.length, xrefTable);

        //since we consolidate, no prev! [adjust /Prev -> rawparsing + offset]
        var from1 = 0;
        var to1 = offsetSig+start.length;
        var from2 = to1 + crypto.length;
        var to2 = (array.length - from2) - 1;
        var byteRange = '['+pad10(from1)+' '+pad10(to1 - 1)
            + ' ' +pad10(from2 + 1)+ ' ' + pad10(to2) + ']';
        array = updateArray(array, (offsetSig + offsetByteRange),
                            byteRange);

        return [array, [from1, to1 - 1, from2 +1, to2]];
    }

    async function appendSig(webcrypto, pdf, root, rootSuccessor, date, password) {
        //copy root and the entry with contents to the end
        var startRoot = pdf.stream.bytes.length + 1;

        var array = copyToEnd(pdf.stream.bytes, root.offset - 1, rootSuccessor.offset);

        //since we signed the first one, we know how the pdf has to look like:
        var offsetAcroForm = find(array, '/AcroForm<</Fields', startRoot);
        var endOffsetAcroForm = find(array, ']', offsetAcroForm);

        var annotEntry = findFreeXrefNr(pdf.xref.entries);
        var sigEntry = findFreeXrefNr(pdf.xref.entries, [annotEntry]);

        var appendAnnot = ' ' + annotEntry + ' 0 R';
        array = insertIntoArray(array, endOffsetAcroForm, appendAnnot);

        //we need to add Annots [x y R] to the /Type /Page section. We can do that by searching /Annots
        var pages = pdf.catalog.catDict.get('Pages');
        //get first page, we have hidden sig, so don't bother
        var contentRef = pages.get('Kids')[0];
        var xref = pdf.xref.fetch(contentRef);
        var offsetAnnotEnd = xref.get('#Annots_offset');
        //we now search ], this is safe as we signed it previously
        var endOffsetAnnot = find(array, ']', offsetAnnotEnd);
        var xrefEntry = pdf.xref.getEntry(contentRef.num);
        var xrefEntrySuccosser = findSuccessorEntry(pdf.xref.entries, xrefEntry);
        var offsetAnnotRelative = endOffsetAnnot - xrefEntrySuccosser.offset;
        var startContent = array.length;
        array = copyToEnd(array, xrefEntry.offset, xrefEntrySuccosser.offset);
        array = insertIntoArray(array, array.length + offsetAnnotRelative, appendAnnot);

        var startAnnot = array.length;
        var append = annotEntry + ' 0 obj\n<</F 132/Type/Annot/Subtype/Widget/Rect[0 0 0 0]/FT/Sig/DR<<>>/T(signature'+annotEntry+')/V '+sigEntry+' 0 R>>\nendobj\n\n';
        array = insertIntoArray(array, startAnnot, append);

        var startSig = array.length;
        var start = sigEntry+ ' 0 obj\n<</Contents <';
        //TODO: Adobe thinks its important to have the right size, no idea why this is the case
        var crypto = new Array(round256(1024 * 6)).join( '0' );
        var middle = '>\n/Type/Sig/SubFilter/adbe.pkcs7.detached/Location()/M(D:'+now(date)+'\')\n/ByteRange ';
        var byteRange = '[0000000000 0000000000 0000000000 0000000000]';
        var end = '/Filter/Adobe.PPKLite/Reason()/ContactInfo()>>\nendobj\n\n';
        //all together
        var append2 = start+crypto+middle+byteRange+end;
        array = insertIntoArray(array, startSig, append2);

        let sha256Buffer = await webcrypto.subtle.digest('SHA-256', array);
        let sha256Hex = pvutils.bufferToHexCodes(sha256Buffer);

        var prev = pdf.xref.xrefBlocks[0];
        var startxref = array.length;
        var xrefEntries = [];
        xrefEntries[0] = {offset:0, gen:65535, free:true};
        xrefEntries[pdf.xref.topDict.getRaw('Root').num] = {offset:startRoot, gen:0, free:false};
        xrefEntries[contentRef.num] = {offset:startContent, gen:0, free:false};
        xrefEntries[annotEntry] = {offset:startAnnot, gen:0, free:false};
        xrefEntries[sigEntry] = {offset:startSig, gen:0, free:false};
        var xrefTable = createXrefTableAppend(xrefEntries);
        xrefTable += createTrailer(pdf.xref.topDict, startxref, sha256Hex, xrefEntries.length, prev);
        array = insertIntoArray(array, array.length, xrefTable);

        var from1 = 0;
        var to1 = startSig + start.length;
        var from2 = to1 + crypto.length;
        var to2 = (array.length - from2) - 1;
        var byteRange = '['+pad10(from1)+' '+pad10(to1 - 1) + ' ' +pad10(from2 + 1)+ ' ' + pad10(to2) + ']';

        array = updateArray(array, from2 + middle.length, byteRange);
        return [array, [from1, to1 - 1, from2 +1, to2]];
    }

    const api = {
        makeSignatureSpace: function(pdfRaw, crypto){
            const date = new Date();

            let pdf = api.parsePDF(pdfRaw);
            var root = findRootEntry(pdf.xref);

            var rootSuccessor = findSuccessorEntry(pdf.xref.entries, root);

            if (!isSigInRoot(pdf)) {
                return newSig(crypto, pdf, root, rootSuccessor, date);
            } else {
                return appendSig(crypto, pdf, root, rootSuccessor, date);
            }
        },
        parsePDF: function(pdfRaw) {
            if (pdfRaw instanceof ArrayBuffer)
                pdfRaw = new Uint8Array(pdfRaw);

            let pdf = new PDFDocument({evaluatorOptions:{}}, pdfRaw);
            pdf.parseStartXRef();
            pdf.parse();
            return pdf;
        },
        setPDFDocument: function(_PDFDocument) {
            PDFDocument = _PDFDocument;
        }
    };
    api._removeFromArray = removeFromArray;
    api._updateArray = updateArray;
    return api;
}());

exports.PDFSIGN = PDFSIGN;

},{"pvutils":"pvutils"}],2:[function(require,module,exports){
var pkijs = require("pkijs");
var asn1js = require("asn1js");
var pvutils = require('pvutils');

const PDFSIGN = require('./pdfsign').PDFSIGN;

let trustedCertificates = []; // Array of Certificates

const CA64 = "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";

let asn2 = asn1js.fromBER(pvutils.stringToArrayBuffer(pvutils.fromBase64(CA64)));
let CA = new pkijs.Certificate({ schema: asn2.result });
trustedCertificates.push(CA);

function certificadoRaw(provider, certID) {
    return Promise.resolve()
        .then(function () {
            return provider.certStorage.getItem(certID)
                .then(function (cert) {
                    return provider.certStorage.exportCert('raw', cert)
                        .then(function (raw) {
                            return raw;
                        });
                });
        });
}

function certificadoKey(type, provider, certID) {
    return Promise.resolve()
        .then(function () {
            return provider.keyStorage.keys()
        })
        .then(function (keyIDs) {
            for (var i = 0; i < keyIDs.length; i++) {
                var keyID = keyIDs[i];
                var parts = keyID.split("-");

                if (parts[0] === type && parts[2] === certID.split("-")[2]) {
                    return provider.keyStorage.getItem(keyID);
                }
            }
            return null;
        })
        .then(function (key) {
            if (key || type !== "public") {
                return key;
            }

            return provider.certStorage.getItem(certID)
                .then(function (cert) {
                    return cert.publicKey;
                });
        });
}

function primerProveedor(ws) {
    return listarProveedores(ws).then((providers) => {
        if (providers.length > 0)
            return ws.getCrypto(providers[0]);
        else
            throw new Error("Tokens no encontrados");
    });
}

function listarProveedores(ws) {
    return ws.info()
        .then(function (info) {
            let providers = [];
            for (let i = 0; i < info.providers.length; i++) {
                const provider = info.providers[i];
                if (provider.isHardware)
                    providers.push(provider.id);
            }
            return providers;
        });
}

function listarCertificados(provider) {
    let certIDs, keyIDs;
    return Promise.resolve()    // Habilitar en el navegador
        .then(function () {
            if (typeof provider.isLoggedIn == "function") {
                return provider.isLoggedIn()
                    .then(function (ok) {
                        if (ok)
                            return provider.logout();
                    }).then(() => {
                        return provider.login();
                    });
            }
        })
        .then(function () {
            return provider.certStorage.keys()
        })
        .then(function (indexes) {
            certIDs = indexes.filter(function (id) {
                var parts = id.split("-");
                return parts[0] === "x509";
            });
        })
        .then(function () {
            return provider.keyStorage.keys()
        })
        .then(function (indexes) {
            keyIDs = indexes.filter(function (id) {
                var parts = id.split("-");
                return parts[0] === "private";
            });
        })
        .then(function () {
            var certificates = [];
            for (var i = 0; i < certIDs.length; i++) {
                var certID = certIDs[i];
                for (var j = 0; j < keyIDs.length; j++) {
                    var keyID = keyIDs[j];
                    if (keyID.split("-")[2] === certID.split("-")[2]) {
                        certificates.push(certID);
                        break;
                    }
                }
            }
            return certificates;
        });
}

function makeSignature(data, certSimpl, key) {

    let cmsSignedSimpl = new pkijs.SignedData({
        version: 1,
        encapContentInfo: new pkijs.EncapsulatedContentInfo({
            eContentType: "1.2.840.113549.1.7.1" // "data" content type
        }),
        digestAlgorithms: [],
        signerInfos: [
            new pkijs.SignerInfo({
                version: 1,
                sid: new pkijs.IssuerAndSerialNumber({
                    issuer: certSimpl.issuer,
                    serialNumber: certSimpl.serialNumber
                })
            })
        ],
        certificates: [certSimpl]
    });

    //TODO: añadir extensiones
    return cmsSignedSimpl.sign(key, 0, "sha-256", data).then(() => { // SHA-256 por defecto
        var cmsSignedSchema = cmsSignedSimpl.toSchema(true);
        var cmsContentSimp = new pkijs.ContentInfo({
            contentType: '1.2.840.113549.1.7.2',
            content: cmsSignedSchema
        });
        var _cmsSignedSchema = cmsContentSimp.toSchema(true);
        _cmsSignedSchema.lenBlock.isIndefiniteForm = true;

        var block1 = _cmsSignedSchema.valueBlock.value[1];
        block1.lenBlock.isIndefiniteForm = true;

        var block2 = block1.valueBlock.value[0];
        block2.lenBlock.isIndefiniteForm = true;
        var cmsSignedBuffer = _cmsSignedSchema.toBER(false);
        var cmsSignedHex = pvutils.bufferToHexCodes(cmsSignedBuffer);

        return cmsSignedHex;
    });
}

function signpdf(pdfRaw, key, certificate) {
    return PDFSIGN.makeSignatureSpace(pdfRaw, pkijs.getEngine()).then(([pdf, byteRange]) => {
        let data = PDFSIGN._removeFromArray(pdf, byteRange[1], byteRange[2]);
        return makeSignature(data, certificate, key).then((signature) => { // hex
            return PDFSIGN._updateArray(pdf, byteRange[1] + 1, signature);
        });
    });
}

function listSigFields(pdf) {
    const sigFields = [];

    const acroForm = pdf.xref.root.get("AcroForm");
    if(typeof acroForm === "undefined")
        throw new Error("El PDF no tiene firmas!");

    const fields = acroForm.get("Fields");
    // TODO
    // if(window.isRef(fields[0]) === false)
    //      throw new Error("Wrong structure of PDF!");
    for (let i = 0; i< fields.length; i++) {
        const sigField = pdf.xref.fetch(fields[i]);
        const sigFieldType = sigField.get("FT");
        if((typeof sigFieldType === "undefined") || (sigFieldType.name !== "Sig"))
            // throw new Error("Wrong structure of PDF!");
            continue; //Ignorar Tx o Btn
        sigFields.push(sigField);
    }

    if (sigFields.length == 0)
        throw new Error("El PDF no tiene firmas!");

    return sigFields;
}

async function createOCSPReq(serialNumbers) {

    if (!(serialNumbers instanceof Array))
        serialNumbers = [serialNumbers];

    let extension = CA.extensions.find((extension) => {
        return extension.extnID == "2.5.29.14";
    });
    let issuerKeyHash = extension.parsedValue.valueBlock.valueHex;
    let issuerNameHash = await pkijs.getCrypto().subtle.digest('SHA-1', CA.subject.valueBeforeDecode);

    const ocspReq = new pkijs.OCSPRequest();
    let requestList = [];

    serialNumbers.forEach(serialNumber => {
        requestList.push(new pkijs.Request({
	        reqCert: new pkijs.CertID({
		        hashAlgorithm: new pkijs.AlgorithmIdentifier({
			        algorithmId: "1.3.14.3.2.26"
		        }),
		        issuerNameHash: new asn1js.OctetString({ valueHex: issuerNameHash }),
		        issuerKeyHash: new asn1js.OctetString({ valueHex: issuerKeyHash }),
		        serialNumber: new asn1js.Integer({ valueHex: serialNumber}) // cert.serialNumber.valueBlock.valueHex
	        })
        }));
    });

    ocspReq.tbsRequest.requestList = requestList;
    return ocspReq;
};

async function listarFirmas(pdf, ocspReq) {
    const result = {data:[]};
    pdf = PDFSIGN.parsePDF(pdf);

    const sigFields = listSigFields(pdf);
    let serialNumbers = [];
    for (let i in sigFields) {
        let data = {};
        let sigField = sigFields[i];
        let v = sigField.get("V");
        let byteRange = v.get("ByteRange");
        let contents = v.get("Contents");

        let contentBuffer = pvutils.stringToArrayBuffer(contents);

        let asn1 = asn1js.fromBER(contentBuffer);
        let cmsContentSimp = new pkijs.ContentInfo({ schema: asn1.result });
        let cmsSignedSimp = new pkijs.SignedData({ schema: cmsContentSimp.content });

        let certificate = cmsSignedSimp.certificates[0];

        data.numeroSerie = pvutils.bufferToHexCodes(certificate.serialNumber.valueBlock.valueHex);
        serialNumbers.push(certificate.serialNumber.valueBlock.valueHex);

        let subFilter = v.get("SubFilter");
        let filter = v.get("Filter");
        data.subFilter = subFilter.name.toUpperCase();


        // Fecha de la firma desde el documento PDF
        // TODO: mejorar
        var date = v.get("M");
        var pattern = /D:(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})-0(\d{1})'00'/;

        if (date != undefined)
            data.fechaFirma = date.replace(pattern, '$3/$2/$1 $4:$5:$6');

        // Limpiar Campo de la firma
        let signedDataBuffer = PDFSIGN._removeFromArray(pdf.stream.bytes,
                                                        byteRange[1],
                                                        byteRange[2]);
        // Limpiar datos
        signedDataBuffer = PDFSIGN._removeFromArray(signedDataBuffer,
                                                    byteRange[1]+byteRange[3],
                                                    signedDataBuffer.length);

        data.autenticidad = await cmsSignedSimp.verify({signer: 0, data: signedDataBuffer,
                                                        trustedCertificates: trustedCertificates});

        data.cadenaConfianza = await certificate.verify(trustedCertificates[0]);
        // data.certificado = pvutils.toBase64(pvutils.arrayBufferToString(certificate.tbs));
        data.certificado = certificate;
        data.ocsp_estado = 2; // Desconocido por defecto.
        result.data.push(data);
    }

    let ocspReqBuffer = (await createOCSPReq(serialNumbers)).toSchema(true).toBER(false);

    if (ocspReq != undefined && typeof ocspReq == 'function'){
        try {
            [statusCode, ocspResBuffer] = await ocspReq(ocspReqBuffer);

            const asn1 = asn1js.fromBER(ocspResBuffer);
            const ocspRespSimpl = new pkijs.OCSPResponse({ schema: asn1.result });
            let ocspBasicResp;

            if (ocspRespSimpl.responseStatus.valueBlock.valueDec == 0) { // usar !=
                if("responseBytes" in ocspRespSimpl) {
                    const asn1Basic = asn1js.fromBER(ocspRespSimpl.responseBytes.response.
                                                     valueBlock.valueHex);
		            ocspBasicResp = new pkijs.BasicOCSPResponse({ schema: asn1Basic.result });
                    if (serialNumbers.length != ocspBasicResp.tbsResponseData.responses.length) {
                        // ERROR
                    }
                    for(let i = 0; i < ocspBasicResp.tbsResponseData.responses.length; i++)
	                {
                        const typeval = pvutils.bufferToHexCodes(ocspBasicResp.tbsResponseData.responses[i].
                                                                 certID.serialNumber.valueBlock.valueHex);
                        let subjval = ocspBasicResp.tbsResponseData.responses[i].certStatus.idBlock.tagNumber;

                        let data = result.data.find((data) => {
                            return data.numeroSerie == typeval;
                        });
                        if (data)
                            data.ocsp_estado = subjval;

                        if (subjval == 1) {
                            data.ocsp_fechaRevocacion = ocspBasicResp.tbsResponseData.
                                responses[i].certStatus.valueBlock.value[0].toDate()
                        }
                        data.ocsp_fechaActualizacion = ocspBasicResp.tbsResponseData.responses[i].thisUpdate;
                    }

                } else {
                    // ERROR
                }
            }
        } catch(err) {
            // OCSP no disponible
            console.log("OCSP no disponible:", err);
        }
    }

    return result;
}

function primerCertificado(provider) {
    let certificateRaw;
    let certID;

    let sequence = listarCertificados(provider).then((certificados) => {
        if (certificados.length >0) {
            // Seleccionar el primer certificado
            certID = certificados[0];
            return certificadoRaw(provider, certID);
        } else
            throw new Error("No hay certificados.");
    });

    sequence = sequence.then((raw) => {
        certificateRaw = raw;
        return certificadoKey("private", provider, certID);
    });

    sequence = sequence.then((key) => {
        if (!key)
            throw new Error("Certificado no tiene llave privada.");


        const certSimpl = asn1js.fromBER(certificateRaw);
        const certificate = new pkijs.Certificate({ schema: certSimpl.result });

        return [key, certificate];
    });
    return sequence;
}

function setEngine(nombre, provider) {
    pkijs.setEngine(nombre, provider, new pkijs.CryptoEngine({name: 'local', crypto: provider, subtle: provider.subtle}));
}

exports.listarCertificados = listarCertificados;
exports.listarProveedores = listarProveedores;
exports.certificadoKey = certificadoKey;
exports.certificadoRaw = certificadoRaw;
exports.makeSignature = makeSignature;
exports.signpdf = signpdf;

exports.listarFirmas = listarFirmas;
exports.primerCertificado = primerCertificado;
exports.primerProveedor = primerProveedor;
exports.setEngine = setEngine;

},{"./pdfsign":1,"asn1js":"asn1js","pkijs":"pkijs","pvutils":"pvutils"}],"pdfjs-firma":[function(require,module,exports){
const signutils = require("./signutils");
const PDFSIGN =require("./pdfsign").PDFSIGN;

exports.listarCertificados = signutils.listarCertificados;
exports.listarProveedores = signutils.listarProveedores;
exports.certificadoKey = signutils.certificadoKey;
exports.certificadoRaw = signutils.certificadoRaw;
exports.finalizarFirmarPDF = signutils.makeSignature;
exports.firmarPDF = signutils.signpdf;

exports.listarFirmas = signutils.listarFirmas;
exports.primerCertificado = signutils.primerCertificado;
exports.primerProveedor = signutils.primerProveedor;
exports.espacioFirma = PDFSIGN.makeSignatureSpace;
exports.parsePDF = PDFSIGN.parsePDF;
exports.removeFromArray = PDFSIGN._removeFromArray;
exports.updateArray = PDFSIGN._updateArray;
exports.setPDFDocument = PDFSIGN.setPDFDocument;
exports.setEngine = signutils.setEngine;

},{"./pdfsign":1,"./signutils":2}]},{},[])("pdfjs-firma")
});